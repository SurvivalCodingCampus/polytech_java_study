# 클래스와 인스턴스

### ✏️ 주요 용어 정리

- **오브젝트(Object)**: 현실 세계의 모든 객체
- **클래스(Class)**: 오브젝트를 가상세계용으로 구체화 (예) 붕어빵 틀
- **인스턴스(Instance)**: 클래스를 활용해 메모리 상에 만들어 낸 것 (예) 붕어빵


<hr>

### 📛 Java의 명명 규칙

| 클래스명 | 명사 | **P**ascal**C**ase | (예) MonsterInfo |
| --- | --- | --- | --- |
| 필드명 | 명사 | **c**amel**C**ase | (예) itemList |
| 메소드명 | 동사 | **c**amel**C**ase | (예) setHp |


<hr>

### 🤝 클래스 익숙해지기

```java
// 용사 클래스 만들기
public class Hero{
	String name; // 이름
	int hp; // hp 
	
	void attack(){}     // 싸우기
	void run(){}        // 도망
	void sit(int sec){} // 앉기
	void slip(){}       // 넘어지기
	void sleep(){
		// 잠자기
		this.hp = 100;
		System.out.println(this.name + "는 잠을 자고 회복했다");
	} 
}
```

- `this` : **현재 객체 자신을 참조**할 때 사용하는 키워드 (컴파일러가 this 객체를 자동 생성)

```java
// Kinoko 몬스터 클래스
public class Kinoko{
	int hp = 50;
	final int level= 10; // 필드(field)를 상수로 선언
	
	void setHp(int hp){
		this.hp = hp;
	}
}
```

- `final` : 한 번 값을 할당하면 **변경할 수 없다** (변수, 함수, 클래스 등에도 동일하게 적용)

```java
// 인스턴스 생성하기
Hero hero = new Hero();
Kinoko kinoko = new Kinoko();
```

- `new` 키워드: 객체 생성 시 사용하는 키워드
  - `new` 로 객체를 생성하면 runtime 중에 메모리가 필요한 만큼만 할당된다
  - 컴파일 할 에 미리 메모리를 할당하는 방식이 아니라 **필요한 시점에 필요한 만큼만 객체를 생성하는 방법으로 메모리를 효율적으로 사용할 수 있도록 한다.**


<hr>

### ❓클래스를 사용하는 이유
> 💡 **효율적인 프로그램 설계**와 **유지보수성**, **재사용성**을 위해 클래스를 사용한다
- **재사용성과 확장성 확보**
  - **재사용성**: 클래스를 한 번 정의하면, 편하게 객체를 여러 개 만들어서 재사용할 수 있다
  - **확장성**: 손쉽게 기능을 확장하거나 다양하게 바꿀 수 있다
- **코드 관리 및 분할 용이: 클래스 단위로 분리**하면 파일 관리가 쉬워지고 역할 분담도 명확하다
- **캡슐화 및 정보 은닉:** 클래스 내부의 데이터를 숨기고, 외부에서 접근할 때는 **getter/setter**를 통해 제어 가능 → 코드의 안정성과 보안성이 올라감


<hr>

### 🚫 클래스 내부에 출력문 사용을 지양해야하는 이유
1. **책임 분리 원칙(SRP: Single Responsibility Principle) 위배**
   - 클래스는 데이터와 행동(로직)만 가져야 하고, 입출력(표현)은 다른 곳에서 처리해야 한다
   - **출력이라는 별도의 책임.** 클래스의 본연의 역할(데이터 처리, 로직 수행)을 흐리게 만든다

     > ❗(예) `Student` 클래스는 학생 정보를 담는 데 집중해야 지, 출력까지 책임지면 역할이 무거워짐.
2. **재사용성과 확장성 저하** 
   - `sysout.print()`가 하드코딩되어 있으면 다른 용도로 재사용하기 어려워짐.
   - (예) 웹, 파일 저장, 로깅 등 다양한 방식으로 출력해야 할 때 수정이 필요함.