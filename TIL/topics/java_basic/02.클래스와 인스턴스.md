# 클래스와 인스턴스

### ✏️ 주요 용어 정리

- **오브젝트(Object)**: 현실 세계의 모든 객체
- **클래스(Class)**: 오브젝트를 가상세계용으로 구체화 (예) 붕어빵 틀
- **인스턴스(Instance)**: 클래스를 활용해 메모리 상에 만들어 낸 것 (예) 붕어빵


<hr>

### 📛 Java의 명명 규칙

| 클래스명 | 명사 | **P**ascal**C**ase | (예) MonsterInfo |
| --- | --- | --- | --- |
| 필드명 | 명사 | **c**amel**C**ase | (예) itemList |
| 메소드명 | 동사 | **c**amel**C**ase | (예) setHp |


<hr>

### 🤝 클래스 익숙해지기

```java
// 용사 클래스 만들기
public class Hero{
	String name; // 이름
	int hp; // hp 
	
	void attack(){}     // 싸우기
	void run(){}        // 도망
	void sit(int sec){} // 앉기
	void slip(){}       // 넘어지기
	void sleep(){
		// 잠자기
		this.hp = 100;
		System.out.println(this.name + "는 잠을 자고 회복했다");
	} 
}
```

- `this` : **현재 객체 자신을 참조**할 때 사용하는 키워드 (컴파일러가 this 객체를 자동 생성)

```java
// Kinoko 몬스터 클래스
public class Kinoko{
	int hp = 50;
	final int level= 10; // 필드(field)를 상수로 선언
	
	void setHp(int hp){
		this.hp = hp;
	}
}
```

- `final` : 한 번 값을 할당하면 **변경할 수 없다** (변수, 함수, 클래스 등에도 동일하게 적용)

```java
// 인스턴스 생성하기
Hero hero = new Hero();
Kinoko kinoko = new Kinoko();
```

- `new` 키워드: 객체 생성 시 사용하는 키워드
  - `new` 로 객체를 생성하면 runtime 중에 메모리가 필요한 만큼만 할당된다
  - 컴파일 할 에 미리 메모리를 할당하는 방식이 아니라 **필요한 시점에 필요한 만큼만 객체를 생성하는 방법으로 메모리를 효율적으로 사용할 수 있도록 한다.**


<hr>

### ❓클래스를 사용하는 이유
> 💡 **효율적인 프로그램 설계**와 **유지보수성**, **재사용성**을 위해 클래스를 사용한다
- **재사용성과 확장성 확보**
  - **재사용성**: 클래스를 한 번 정의하면, 편하게 객체를 여러 개 만들어서 재사용할 수 있다
  - **확장성**: 손쉽게 기능을 확장하거나 다양하게 바꿀 수 있다
- **코드 관리 및 분할 용이: 클래스 단위로 분리**하면 파일 관리가 쉬워지고 역할 분담도 명확하다
- **캡슐화 및 정보 은닉:** 클래스 내부의 데이터를 숨기고, 외부에서 접근할 때는 **getter/setter**를 통해 제어 가능 → 코드의 안정성과 보안성이 올라감


<hr>

### 🚫 클래스 내부에 출력문 사용을 지양해야하는 이유
1. **책임 분리 원칙(SRP: Single Responsibility Principle) 위배**
   - 클래스는 데이터와 행동(로직)만 가져야 하고, 입출력(표현)은 다른 곳에서 처리해야 한다
   - **출력이라는 별도의 책임.** 클래스의 본연의 역할(데이터 처리, 로직 수행)을 흐리게 만든다

     > ❗(예) `Student` 클래스는 학생 정보를 담는 데 집중해야 지, 출력까지 책임지면 역할이 무거워짐.
2. **재사용성과 확장성 저하** 
   - `sysout.print()`가 하드코딩되어 있으면 다른 용도로 재사용하기 어려워짐.
   - (예) 웹, 파일 저장, 로깅 등 다양한 방식으로 출력해야 할 때 수정이 필요함.

<hr>


### ⛳️ 클래스형과 참조

- 가상 세계: 컴퓨터의 메모리 영역
- 인스턴스: heap 영역 안에 확보된 메모리

| 구역 (영문명) | 설명 | 예시 | 메모리 할당 시점 |
| --- | --- | --- | --- |
| **CODE** | 함수, 제어문, 상수 등 프로그램 코드 영역 | 함수, if문, const 변수 등 | 컴파일 시 크기 결정 |
| **DATA** | 초기화된 전역변수 저장 영역 | `int a = 10;` (전역) | 컴파일 시 크기 결정 |
| **BSS** (Blocked Started Symbol) | 초기화되지 않은 전역변수 저장 영역 | `int b;` (전역) | 컴파일 시 크기 결정 |
| **HEAP** | 동적으로 할당되는 메모리 영역 | `malloc()`, `new` 등 | 실행 중 동적 할당 |
| **STACK** | 지역변수 및 함수 호출 정보 저장 | 지역 변수, 매개변수 등 | 실행 중 자동 할당 |


<hr>


### 👻 기본형(privitive) vs 참조형(reference)

- 기본형 `primitive` : int, double, float, bool 등 값을 저장하기 위한 기본형 타입
- 참조형 `reference` : new로 생성되는 인스턴스인 레퍼런스 타입
    - 초기값이 `null` 로 설정된다
- 필드의 초기값
    
    
    | int, short, long | 0 |
    | --- | --- |
    | char | \u0000 |
    | boolean | false |
    | int[ ] | null |
    | String | null |


<hr>


### 🥑 생성자

```java
package com.survivalcoding;

public class Sword {
    String name;
    int damage;

    Sword(String name) {
        this.name = name;
        damage = 10;
    }
}
```
- 객체지향에서는 필드의 값을 직접 초기화하지 않고, 생성자를 통해서만 초기화한다. 이는 역할과 책임을 분리하기 위함이다


<hr>



### 🔖 Static

| 항목 | **non-static (일반 변수/메서드)** | **static (정적 변수/메서드)** |
| --- | --- | --- |
| **메모리 위치** | Heap 영역(객체 내부에 생성됨) | Method Area(클래스 로딩 시 생성됨) |
| **생성 시점** | 객체가 생성될 때 | 클래스가 처음 로딩될 때 (JVM이 메서드 영역에 할당) |
| **소멸 시점** | 객체가 가비지 컬렉션될 때 | 클래스가 언로드될 때까지 유지 |
| **접근 방식** | 객체를 통해 접근 <br> (예) `obj.field`, `obj.method()` | 클래스명으로 직접 접근 <br> (예) `ClassName.field`, `ClassName.method()` |
| **메서드 내에서의 사용 제한** | 인스턴스 메서드에서는 static 및 인스턴스 모두 접근 가능 | static 메서드에서는 인스턴스 필드/메서드 접근 불가 (`this` 사용 불가) |
| **메모리에 존재 수** | 객체마다 개별적으로 존재 | 클래스당 1개만 존재 (모든 객체가 공유) |

<br>

- `static`은 **공유 / 공통 / 전역의 의미** → ****클래스당 단 1개만 존재 → 모든 객체가 공유
- `static` 메서드는 인스턴스 생성 없이 호출 가능하지만, 인스턴스 정보(`this`)를 사용할 수 없다
- `static` 메서드는 **클래스가 로드될 때 생성되어**, 보통 **프로그램이 종료될 때까지 유효하다**

