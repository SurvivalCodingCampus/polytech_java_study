## TODAY NOTE JAVA  [ 25.06.23 ]

### 상속 (inheritance)
- “이전에 만든 클래스와 닮았지만, 일부 다른 클래스"를 만들 필요가 있을 경우가 늘어날 것이다.

### 복사 붙여넣기의 문제점
- 추가, 수정에 시간이 걸림
- 소스의 파악이나 관리가 어려워 짐
-  해결책으로 “상속" 을 활용

### 올바른 상속
- 올바른 상속은 “is-a 원칙” 이라고 하는 규칙에 따른 상속을 말한다
- 예) SuperHero is a Hero
  (SuperHero 는 Hero의 한 종류 이다)

### 잘못된 상속
- 현실 세계의 등장인물 사이에 개념적으로 'is-a 관계가 되지 못 함에도 불구하고 상속을 사용한 경우'가 “잘못 된 상속" 이다.

### 잘못된 상속을 하면 안 되는 이유
- 클래스를 확장할 때 현실세계와의 모순이 생긴다
- 객체 지향의 3대 특징 중 1가지 “다형성" 을 이용할 수 없게 된다

### 구체화와 일반화의 관계
- 자식클래스 일 수록 구체화 되고,부모 클래스 일 수록 추상적인 것으로 일반화 된다.


### 상속의 기초
- extends를 사용하여 기존 클래스를 기초로 하는 새로운 클래스를 정의 할 수 있다
- 부모 클래스의 멤버는 자동적으로 자식 클래스에 상속되므로, 자식 클래스에는 추가 된 부분만 기술 하면 된다
- 부모 클래스에 있는 메소드를, 자식 클래스에서 재작성 할 경우 이것을 오버라이드 한다고 한다
- final 을 붙인 클래스는 상속이 되지 않고, final 이 붙은 메소드는 오버라이드 되지 않는다
- 올바른 상속이란 “자식 클래스 is-a 부모 클래스"
- 상속에는 “추상적, 구체적" 관계에 있다는 것을 정의하는 역할도 있음

### 인스턴스
- 인스턴스는 내부에 부모클래스의 인스턴스를 가지는 다중구조를 가진다
- 보다 외측의 인스턴스에 속하는 메소드가 우선적으로 동작한다
- 외측의 인스턴스에 속하는 메소드는 super 을 사용하여 내측 인스턴스의 멤버에 점근할 수 있다

### 생성자 동작
- 다중구조의 인스턴스가 생성되는데, JVM 는 자동적으로 가장 외측 인스턴스의 생성자를 호출
- 모든 생성자는, “부모 인스턴스의 생성자"를 호출 할 필요가 있다
- 생성자의 선두에 super() 가 없으면, 암묵적인 “super();” 가 추가 됨

### 생성자를 쓰는 이유
- 남이 편하게 쓰도록 하기 위해서

### property : 게터 세터 메소드를 일단 필드에 있는 변수나 상수를 사용 하는 것처럼 제공 하는 것
