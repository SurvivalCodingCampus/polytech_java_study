# Java 상속 (Inheritance) 요약

## 상속이란?

이전에 만든 클래스와 닮았지만, 일부 다른 클래스를 만들 필요가 있을 때 사용하는 기능

### 기본 구조
```java
public class SuperHero extends Hero {
    // 추가 필드와 메소드
}
```

## 상속의 기본 개념

### 1. 복사 붙여넣기의 문제점
- 추가, 수정에 시간이 걸림
- 소스의 파악이나 관리가 어려워짐

### 2. 상속의 해결책
- `extends` 키워드 사용
- 부모 클래스의 멤버를 자동으로 상속받음
- 자식 클래스에는 추가된 부분만 기술

## 주요 특징

### 1. 오버라이드 (Override)
- 부모 클래스의 메소드를 자식 클래스에서 재정의
- `@Override` 어노테이션 사용 권장

```java
@Override
public void run() {
    System.out.println("멋지게 뛰었다!");
}
```

### 2. super 키워드
- 부모 클래스의 멤버나 생성자를 참조
- 생성자에서 `super(name, hp)` 호출
- 메소드에서 `super.attack(slime)` 호출

### 3. 상속 금지 - final
- `final class`: 클래스 상속 금지
- `final method`: 메소드 오버라이드 금지

```java
public final class String { ... }  // 상속 불가
public final void slip() { ... }   // 오버라이드 불가
```

## 상속의 제한사항

### 1. 다중상속 금지
- Java에서는 단일 상속만 지원
- 인터페이스를 통해 다중 구현 가능

### 2. 생성자와 상속
- 자식 클래스 생성자는 반드시 부모 생성자를 호출해야 함
- 명시적으로 `super()` 호출하지 않으면 암묵적으로 추가됨

## 올바른 상속

### is-a 원칙
- **올바른 예**: SuperHero is a Hero (슈퍼히어로는 히어로의 한 종류)
- **잘못된 예**: Potion extends Weapon (포션은 무기가 아님)

### 구체화와 일반화
- **부모 클래스**: 더 추상적이고 일반적
- **자식 클래스**: 더 구체적이고 특화됨

```
Character (가장 일반적)
    ↑
   Hero / Wizard
    ↑       ↑
SuperHero / GreatWizard (가장 구체적)
```

## 잘못된 상속을 피해야 하는 이유

1. **현실세계와의 모순**: 클래스 확장 시 개념적 문제 발생
2. **다형성 활용 불가**: 객체지향의 3대 특징 중 하나를 사용할 수 없게 됨

## 상속의 핵심 정리

### 기초 사항
- `extends`로 클래스 상속
- 부모 클래스 멤버 자동 상속
- 오버라이드로 메소드 재정의
- `final`로 상속/오버라이드 금지

### 인스턴스 구조
- 다중구조: 내부에 부모 클래스 인스턴스 포함
- 외측 메소드가 우선 동작
- `super`로 내측 인스턴스 접근

### 생성자 동작
- JVM이 자동으로 외측 생성자 호출
- 모든 생성자는 부모 생성자 호출 필요
- 암묵적 `super()` 자동 추가