# TIL 25.07.07 (Today I Learned)

## 인스턴스 기본 조작

## Object 클래스

모든 클래스의 최상위(루트) 클래스 - 클래스를 자동으로 상속받는다.

## 대표 메서드

### 1. toString()

객체 안에 내용을 알기 쉽게 보여주는 메서드
List / Set / Map

### 2. equals()

equals / ==

### 3. hashCode()

### 4. Collections.sort()

### 얕은 복사 / 깊은 복사

clone
Cloneable

instance 라는 데다가
String[] args 는 특수한 거여서
모든 타입의 인스턴스를 대입할 수 있습니다.
상속 계층을 확인 했을 떄
타입 하이러하키 창을 켜면
모든 상속 관계를 볼 수 있스비다.

모든 클래스는 객체다.
오브젝트를 암묵적으로 상속 받는다.
퍼블릭 클래스 오브젝트 해가주고

오브젝트가 꼭대기에 있다!!
이 안에 어떤 기능들이 있는지
파일 스트럭스??
M 은 매서드
PPT에서 언급하는 것들이 중요하는 거지

히어로를 생성을 하고 나서 히어로. 찍었을때
내가 만들지 않은 것이 있다는 것이 있다는거지
투 스트링은 오버라이드 해가지고 원하는 결과를

히어로를 프린트 하면 요거예요 요거

위치.타입(클래스 이름)@해시코드

직접적으로 쓰지 않아도 되요

있는 것들을 표현하고 싶다.

정신없는 애가 많다.
정신없어 Person
여기에 정보들이 있어요.
이런식으로 오버라이드 해가지고 원하는 데로 쓰면 되여.

위로 올릴꼐요 제가
생성자

맨 아래에다가 많이 만들기 때문에
static은 모아 놓을 게요\
원하는데로
나오는 거야

리스트에 사이즈를 찍으면 1이 나오겠지
예상을 해서 찍어보시죠
자 0,1 둘중에 하나 찍으시면 돼.
마지막꺼
1번 넣고 2번 지우고 뭘까여??

이름이 다르다는 것을 알수 있어요
리스트 하고 set은

set은 속도가 굉장히 빨라요.

실행해보면 똑같죠!!
같아야지 중복을 제거하잖아
어떤 식으로 중복을 체크하는 지를
add하면 둘다 들어갑니다??
모르죠 모르니까
equals가 어디에서 왔는지는
오브젝트에서 왔고 내가 제정의를 해서 뭔가를 해보겠다.

우리가 봤잖아
둘이는 달라
이렇게 하면은 주소 비굔데
.equals는 같아..
동등성을
그렇게 프로그램을 짜고 싶은 거야
히어로 안에다가 equals 안에다가 제정의를 할께요
여기 보시면 샘플인데

프리미티브 타입은 ==으로 비교하면 되 아니면

자동완성으로 만들 수가 있는데 generate 메뉴에 equals해서 ok

== 은 주소 비교라서 T/F
equals 는 이름만으로 동등성을 체크하는거야?
동등성 규칙을 재정의를 하는거야 이런식으로 다시 재정의를 하면
list / set

Hash 값 기준으로 동등성 체크르 해요
HashSet 같은거?
Hashcode()
Hash 값을 재정의를 해야해요
하나만 재정의 하는게 아니라 둘다 해줘야 해요
List / Set ?!!

자동으로 만들수 있다구?!
둘다 같게 작동하게??

왜하냐??
복사가 아니라 두 군데에 동작을하게 하는거잖아요
레퍼런스 기반으로하는거 긴한데 편하게 규칙을 정하는거예요.
언제 어떻게 사용할지 모르기 떄문에

Map, Set 이 엄청 빠르게 검색을 한다??
둘다 항상 동일하게 속도가 엄청 빨라

시간복잡도
이게 데이터 양에 따라서
빅 오 표기법

equals로 찾는 방법이
이름 하나가지고 재정의를 하면은

필드가 복잡하게 더 많으면 많을 수록 더 오래 걸릴꺼야

칼 안에 있는 거까지 다 비교해줄 꺼야

어떤 하나의 숫자로 만들거든요
숫자 연산이고 논리연산이거든요

단순하게 곱하고 더하고 이헌게 더 빠르고요

객체를 표현하는 숫자값이

비교 로직이 여기서 돌거든요

해시코드는 ==으로 비교를 하거든요

하나씩 보겠다는 거야?!!
비교를 하나하나 다 하겠다는거가
해시코드는 숫자로 표현을 하는거야 1번 = 1번?
주민번호만 본다?? 이런 느낌?!

모든 객체는 해시값을 가진다.

해시 알고리즘의 허점
해시값이 같다고 해서 무조건 같은 거는 아닐 수 있다.
둘이서 같은 해시값이 나올 수도 있다는 거야

중요한건 List / Set / Map
해시값

List는 순차검색이라서 느림
equals 를 최대한 않돌리는게 빠른거여서

Integer

Collections.sort()
컬랙션 내부를 정렬을 해줘서 오름차순 정렬을 해주거든요.
?

Hero 를 정렬하려면 기준을 정해줘야해
이름 , hp 니까?!!
규칙에 안맞아서??
compareTo(T) 매서드 대상을 T로 받아
Cmpareable 인터페이스를 구현해줘야만 가능!
숫자
implements Comparables<Hero>
재정의 해줍니다. 그럼 알아서 들어와요

이름으로 해보겠습니다.
글자 대소비교를 해야해 compareTo를 호출
hp를 가지고 하면 조금 쉬워
String.java에 정의
정의된 룰
반대로 하려면 +, - 뒤집기?
규칙을 뒤집기
Comparator
compare

인스턴스의 복사 PPT 13장 T
복사 개념이 아니라는거야

동일한 속성을 가진 인스턴스를 만들고 싶어
복사
안에 있는 걸 하나하나 다 복사해야 한다. 오브젝트는

얕은 복사
레퍼런스 복사 주소만 복사 된다는 개념
.clone() 해서 복사해라! 암묵적인 룰

lang 마커 인터페이스
clone 자동으로 생성
Cloneable 인터페이스

모든 언어들이 얕은 복사가 디폴트예요.
필요할떄 인스턴스를 생성해 준다고??
효율이 좋다.

깊은 복사
진짜루 다 복사하는거야

toString 객체 안에 내용을 알기 쉽게 보여주는 메서드
equals
hashCode
Cloneable
얕은 복사 / 깊은 복사

비유를 통해서 설명 (내가 이해한 내용으로)

Date 년월일 시간 시분초 까지 전부 가지고 있는
동등성 비교 규칙
List/ Set / Map 까지 전부 동일한 객체
sort가 되게 만들기 Collections.sort()
clone()을 하면 깊은 복사

NotebookLM