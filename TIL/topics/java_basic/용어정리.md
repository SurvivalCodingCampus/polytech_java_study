# 추상클래스와 인터페이스 (25.06.24)
* 클래스는 크게 **일반 클래스**와 **추상 클래스**로 나뉨. **추상 클래스**는 클래스 내 '추상 클래스'가 하나이상 포함하거나
abstract로 정의된 경우를 말함.
* **인터페이스**는 모든 메소드가 추상 메소드인 경우

### 추상클래스와 인터페이스의 차이점
추상클래스는 일부 구현된 설계도, 인터페이스는 기능 약속을 위한 설계도

*추상클래스* -> "is-a"관계 (Dog is an Animal -> Dog extends Animal)

*인터페이스* -> "can-do"관계 (Bird can Fly -> Bird implements Flyable)

### 메모
* protected는 자식 클래스에서는 접근이 쉽지만,
외부(예: 테스트 코드)에서는 직접 접근이 불가능하다.
따라서 외부 접근을 고려한다면, private으로 필드를 감추고
public getter/setter를 제공하는 방식이 더 명확하고 덜 혼란스럽다.



### 참고
[자바추상클래스](https://m.blog.naver.com/minsuuuus/222228495226)

[오버라이딩(Overriding)과 오버로딩(Overloading)](https://yeoonjae.tistory.com/entry/JAVA-%EC%98%A4%EB%B2%84%EB%9D%BC%EC%9D%B4%EB%94%A9Overriding%EA%B3%BC-%EC%98%A4%EB%B2%84%EB%A1%9C%EB%94%A9Overloading%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90)

---
# 상속 용어 정리 (25.06.23)

* 상속(Inheritance)은 부모가 자식에게 물려주는 행위를 말한다. OOP에서도 부모 클래스의 필드&메서드를 자식 클래스에게 물려줄 수 있음.
* public class PoisonSlime extends Slime {

  } 
위와 같이 부모 클래스를 extends 뒤에 기술함.
프로그램에서는 자식이 부모를 선택함.

▶ 자바에서는 다중 상속을 허용하지 않음!! 여러 개 부모 클래스를 상속할 수 없음. 따라서 extends 뒤에는 단 하나의 부모 클래스만이 와야 함.

* super = 부모 클래스에 접근하는 키워드
상속구조에서, 자식 클래스는 부모 클래스의 속성과 매서드를 상속받아 사용할 수 있는데, super를 쓰면 부모의 기능을 호출하거나 접근가능.

▶ this. 나 자신
▶ super. 부모

* 오버라이딩 : 부모 클래스에서 정의한 매서드를 자식 클래스에서 재정의
부모의 것을 그대로 쓰는 게 아니라 입맛대로 바꿔서 쓰겠다? 그런 의미

@Override
public void attack(Hero hero) {
super.attack(hero);
~
}

@Override는 부모에 정의된 매서드를 재정의하고 있다는 표시

---
# 캡슐화 용어 정리 (25.06.17)

* 캡슐화란,
캡슐화는 클래스 내부의 데이터에 외부에서 직접 접근하지 못하도록 막고, 대신 메서드를 통해서만 접근하게 하여
데이터를 안전하게 보호하는 개념. 특히 현실 세계에서는 들어갈 수 없는 잘못된 값이 필드에 저장되지 않도록 제어하는 데 매우 중요

* 접근 제한자에 따른 멤버 접근 규칙
private으로 선언된 필드는 해당 클래스 내부에서만 접근 가능
public으로 선언된 필드나 메서드는 어떤 클래스에서도 자유롭게 접근 가능

* 캡슐화를 올바르게 적용하려면, 클래스는 public으로 선언하고, 필드는 반드시 private로 선언.
필드에 접근하고 수정하기 위해서는 public 매서드(getter,setter)를 따로 만들어 제공함.


##클래스 생성자 용어 정리 (25.06.16)

* 클래스 변수는 값이 아니라 객체의 주소(참조)를 저장함.
그래서 하나의 객체를 여러 변수가 가리킬 수 있으며, 한 쪽에서 바꾸면 다른 쪽도 바뀜.


* 생성자는 객체를 만들 때 자동으로 실행되는 메서드. 여러 개 만들 수 있음(오버로딩), 그리고 this로 다른 생성자를 내부에서 부를 수도 있음.


* 정적 멤버(static)이 붙은 변수나 메서드는 클래스명, 변수명으로 바로 쓸 수 있고, 모든 인스턴스가 같은 값을 공유함.

---
# 객체지향언어 용어 정리 (25.06.10)

오브젝트(object) : 현실 세계 모든 객체(사물이 아닌 경우가 많음)

클래스(class) : 객체를 만들어내기 위한 설계도 / 변수와 매서드의 집합

인스턴스(instance) : 설계도를 바탕으로 가상 세계에 구현된 구체적인 실체(실체화된 인스턴스는 메모리에 할당)

*직무에선 오브젝트를 인스턴스와 같은 개념으로 혼용하며 사용된다함.

클래스를 만드는 이유는 재사용성 때문에 만듦.



final : 변경불가 키워드(const 같은 거) _ 한번 초기화되면 이후로 값이 바뀔 수 없음.
this : 현재 객체를 참조하는 키워드 _ 현재 객체 자기 자신을 가리킴. 


## 메모
객체마다 고유의 속성이 있는데, class로 표현하면 이해하기가 수월함.
객체지향을 함으로써 성능면에서는 메리트가 없음(메모리 사용 or 실행 속도 등)

비록 느리고 메모리 사용도 많은 객체지향 방식을 굳이 쓰는 이유가 개발자가 헷갈리지 않게 하려고, 결국 버그를 줄이기 위함.


