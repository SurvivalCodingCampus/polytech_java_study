# 제네릭(Generic), enum

### 제네릭(Generic)

```java
ArrayList<String> list = new ArrayList<>();
```

- **런타임**이 아닌 **컴파일타임**에 타입을 원하는 형태로 정의할 수 있다
- 타입 안정성(Type Safety)을 보장하여, 잘못된 타입 사용을 컴파일 단계에서 방지할 수 있다
- **왜 필요할까?**
    - 기존에는 모든 값을 `Object` 타입으로 다뤄서, 값을 꺼낼 때 형변환(casting)을 해야 했다
    - **만약 잘못된 타입을 넣으면 컴파일 에러가 발생하지 않고, 런타임 에러가 발생한다**
    - 이를 방지하기 위해 제네릭으로 컴파일 단계에서 잘못된 타입 사용을 방지한다

---

### 제네릭을 쓰지 않았을 때 문제점

```java
ArrayList list = new ArrayList();
list.add("Hello");
list.add(123);

String str = (String) list.get(1); 
// 런타임 오류 (Integer cannot be cast to String)
```

- `ArrayList`가 어떤 타입을 저장하는지 명확하지 않으면 값을 꺼낼 때 하나하나 강제 형변환이 필요하다
- 만약 잘못된 형변환을 하면 런타임 에러가 발생

### 제네릭을 사용하면

```java
ArrayList<String> list = new ArrayList<>();
list.add("Hello");
list.add("World");

// String으로 선언했기 때문에 컴파일 에러 발생
// list.add(123); 

String s = list.get(0);  // 형변환 없이 바로 사용 가능
```

---

### 제네릭 장점👍

| **장점** | **설명** |
| --- | --- |
| **타입 안정성** | 컴파일 시점에 잘못된 타입을 막을 수 있다 |
| **형변환 생략** | 형 변환을 생략할 수 있다 |
| **코드 재사용성** | 한 번 작성한 코드를 여러 타입에 적용할 수 있다 |
| **가독성 향상** | 자료구조에 어떤 타입이 들어가는지 명확히 알 수 있어요ㄷ |

---

### 제네릭 클래스 예시

```java
class Pocket<T> {
    private T data;
    public void put(T data) {
        this.data = data;
    }
    public T get() {
        return data;
    }
}
```

```java
// main
Pocket<String> stringPocket = new Pocket<>();
stringPocket.put("안녕");
String msg = stringPocket.get();
```

- `T`는 타입을 의미하는 **임시 매개변수 타입** 이며, 인스턴스를 생성할 때 타입을 지정한다
    - (예) (`<String>`, `<Integer>` 등

---

### 타입 파라미터 명칭 관례

| 문법 | 의미 |
| --- | --- |
| `T` | Type |
| `E` | Element |
| `K` | Key |
| `V` | Value |
| `N` | Number |

---

### 열거형(enum)

```java
public enum AuthState{
	AUTHENTICATED,
	UNAUTHENTICATED,
	AUTHENTICATING,
}
```
- 열거형(enum): 서로 관련 있는 상수들을 하나의 그룹으로 묶어 표현할 수 있는 특수한 클래스 타입