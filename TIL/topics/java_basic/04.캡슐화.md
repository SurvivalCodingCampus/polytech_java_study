# 캡슐화

### 객체지향의 3대 원칙

- 캡슐화
    - **캡슐화가 필요한 이유**
        1. **데이터 보호** – 객체 내부 상태를 외부에서 임의로 변경하지 못하게 함.
        2. **유지보수성 향상** – 내부 구현을 바꿔도 외부 인터페이스는 유지 가능.
        3. **검증 가능** – setter 메서드에서 유효성 검사 가능 (예: null 체크).
            - 개발자의 잘못된 접근에 대한 제어 방법을 제공
            - 특히, 필드에 **현실세계에서 있을 수 없는 값**이 들어가지 않도록 제어
        4. **의도 표현** – 읽기 전용/쓰기 전용 속성을 구분 가능.
- 상속
- 다형성

<hr>

### 접근 지정자

| 제한 범위 | 명칭 | 설정 방법 | 접근 가능한 범위 |
| --- | --- | --- | --- |
| 제한이 엄격 | private | private | 자기 자신의 클래스 |
| 제한이 엄격 | package private (default) | (아무것도 안 씀) | 자신과 같은 패키지에 소속된 클래스 |
| 제한이 엄격 | protected | protected | 자신과 같은 패키지에 소속되던지, 자신을 상속받은 자식 클래스 |
| 제한이 느슨 | public | public | 모든 클래스 |

<hr>

### UML(Unified Modeling Language)
- 패키지명
    - 클래스명
        - `~` : protected 멤버
        - `+` : public 멤버
        - `-` : private 멤버
        - `{static}`: static 멤버를 표현하는 방법
    - 생성자는 따로 추가하지 않는다
- 인텔리제이에서 UML 그려보기
    - Setting - Plugins - Marketplace → PlantUML Integration 설치
        - 이전 버전에서는 Setting 대신 Preference (단축키 `cmd + ,` )
    - 인텔리제이 재시작 → 패키지 폴더 우클릭 → New → PlantUMLFile → Class선택하고 이름 설정
    - UML 제대로 안나오면 터미널에서 `brew install graphviz` 설치 → 인텔리제이 재시작
    - 코드 수정하고 결과 확인하기

        ```
        @startuml
        'https://plantuml.com/class-diagram
        
        scale 1.5
        
        skinparam classAttributeIconSize 0
        Class Hero{
            + String name
            - int hp
        
            + void attack(Kinoko enemy)
            + void bye()
            - void die()
        }
        
        Class Cleric{
            + String name;
            - int hp
            + int mp
        
            +void attack(Kinoko enemy)
            + void pray(int sec)
            + void selfAid()
        }
        
        @enduml
        ```
    - [참고] https://plantuml.com/ko/class-diagram
      
<hr>

### 멤버에 관한 엑세스 지정의 정석 getter / setter

- 객체 지향의 기본: 필드는 모두 `private` 메소드는 전부 `public`
- 그렇다면 필드에 어떻게 접근하나? **메소드를 경유해서 필드를 조작하도록 한다**
    - `getter` 읽기 전용 구현
    - `setter` 쓰기 전용 구현
        - **setter 사용의 장점**: 값을 넣기 전에 유효성검사를 할 수 있다
        - 잘못된 값을 입력받은 경우? 맞는 값으로 정정X → 잘못된 입력임을 알려야한다
            - 예를 들어 setMp(mp) → maxMp보다 큰 값을 매개변수로 받았다
            - 유효성 검사에서 문제가 생겼다면, 더 이상 진행하지 않고 `throw` 한다
                - `throw new IllegalArgumentException("이름은 null이 아니어야 한다");`
                - 다양한 방식이 있지만, `IllegalArgumentException` 이 일반적인 throw 방식
            - 정정하지 않아야 개발자 입장에서 문제가 생긴 부분을 명확히 인지할 수 있다
- 인텔리제이에서의 getter, setter 자동완성
    - getter, setter 만들고자하는 멤버 우클릭 → Generate → getter and setter

<hr>

### UML 관계 표시

| 화살표 종류 | 의미 | 예시 |
| --- | --- | --- |
| `-->` | 연관 관계, 참조 방향 표시 | Hero --> Sword: Hero가 Sword를 가진다 |
| `*-->` | 집합 관계, 부분-전체 관계 (부분은 독립적) |  |
| `o-->` | 합성 관계 |  |
| `<--` | 상속 관계 (화살표가 부모를 가리킴) |  |
| `<..` | 인터페이스 구현 |  |
| `..>` | 의존 관계, 임시 참조 |  |

<hr>

### Null Safty Language

**null 값을 안전하게 처리할 수 있는 기능 또는 구조를 제공하는 프로그래밍 언어**를 의미. Null safety는 흔히 프로그래밍에서 발생하는 오류 중 하나인 `null reference error` 또는 `NullPointerException`을 방지하기 위한 기능.

| 언어 | Null Safety 지원 여부 |
| --- | --- |
| **Java** | ❌ 기본은 미지원 (annotation으로 가능) |
| **C++** | ❌ 직접 지원 없음 |
| **C#** | ✔️ (8.0부터) |
