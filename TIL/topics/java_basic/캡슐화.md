## < 캡슐화 >

### 캡슐화 (encapsulation)

- **클래스 안에 서로 연관있는 속성과 기능들을 하나의 캡슐(capsule)로 만들어 데이터를 외부로부터 보호하는 것** (멤버나 클래스로의 접근을 제어)
    - 하지만, 실수로 속성을 덮어 쓰거나, 잘못된 조작 하는 등의 휴먼 에러 (humanerror) 를 완전히 없앨 수는 없다.
- 개발자의 잘못된 접근에 대한 제어 방법 제공
- 현실세계와 동일하게 프로그래밍하려는 방법 (현실에서 있을 수 없는 값이 들어가지 않도록 제어)

> **캡슐화의 정석**
>   * 클래스는 `public`, 메소드는 `public`, 필드는 `private` 로 지정
>   * 필드에 접근하기 위한 메소드로서 `getter` 나 `setter`를 준비
>   * `setter` 내부에서는 인수의 타당성 검사를 수행

#### [ 멤버에 대한 접근 제어 ]

| 제한 범위  |            명칭             |    설정 방법    |             접근 가능한 범위              |
|:------:|:-------------------------:|:-----------:|:----------------------------------:|
| **엄격** |          private          |  `private`  |             자기 자신의 클래스             |
|        | package private (default) | (아무것도 안 씀)  |        자신과 같은 패키지에 소속된 클래스         |
|        |         protected         | `protected` | 자신과 같은 패키지에 소속되던지, 자신을 상속받은 자식 클래스 |
| **느슨** |          public           |  `public`   |               모든 클래스               |

> **멤버에 관한 액세스 지정의 정석**
>- 필드는 전부 `private`
>- 필드는 일단 다 막아 왜?  
   → 각각의 인스턴스 속성을 외부에서 바꾸지 못하는 게 기본값, 가능한 것만 오픈  
   (예_내이름, 나이는 외부에서 변경 못함)
> - **메소드는 전부 `public`**

#### [ 클래스에 대한 접근 지정 ]

| 제한 범위 |       명칭        |  설정 방법   |      접근 가능한 범위      |
|:-----:|:---------------:|:--------:|:-------------------:|
|  엄격   | package private | 아무것도 안 씀 | 자신과 같은 패키지에 소속된 클래스 |
|  느슨   |     public      | `public` |       모든 클래스        |

> **클래스에 대한 액세스 지정의 정석**
>- 별다른 이유가 없으면 `public` (클래스는 남이 쓰게 하는 게 기본값)

***

### UML

소프트웨어, 아키텍쳐, 데이터 베이스와 같은 복잡한 시스템을 시각화하고 구성 요소의 관게, 특징, 동작을 쉽게 이해할 수 있도록 구현하는 표준화된 방법

- 패키지(비슷한 애들끼리) → 클래스 → 메소드

***

### getter/setter

> - 메소드를 경유한 필드 조작
>- `getter` : 읽기 전용을 구현할 때 사용
>- `setter` : 쓰기 전용을 구현할 때 사용
>- 모든 필드를 private 로 지정 해 다른 클래스로부터 접근이 안 되도록 막고
   메소드를 통해서 접근 하도록 클래스를 설계하는 것이 기본.

#### 메리트

1. Read Only, Write Only 필드의 실현
    + setter는 제공하지 않고 `getter`만 제공하면 외부에서는 값을 읽기만 할 수 있음
    + getter는 제공하지 않고 `setter`만 제공하면, 외부에서 값을 설정할 수만 있고 읽을 수는 없음
2. 필드의 이름 등, 클래스의 내부 설계를 자유롭게 변경 가능
    + 필드를 private으로 숨기고 `getter/setter`로만 접근 -> 클래스 내부의 필드명이나 데이터 구조가 바뀌어도 외부에는 영향 없음
3. 필드로의 액세스를 검사 가능
    ```java
   public void setAge(int age) {
   if (age < 0) {
   throw new IllegalArgumentException("나이는 0 이상이어야 합니다.");
   }
   this.age = age;
   }
   ```
    * setter 메소드 안에서 값의 타당성 검사
    * 특정 테스트가 예외가 발생되어야 하는 것을 테스트 (일부러 터뜨린다)

