- **가상세계** : 메모리 공강
- **인스턴스** : heap 영역 안에 확보된 메모리

| 메모리 영역 | 설명                      | 저장 내용              | 메모리 할당 시점 |
|--------|-------------------------|--------------------|-----------|
| CODE   | 함수, 제어문, 상수             | 프로그램 코드            | 컴파일 시     |
| DATA   | 초기화된 전역 변수              | 초기값이 있는 전역 변수      | 컴파일 시     |
| BSS    | 초기화되지 않은 전역 변수          | 초기값이 없는 전역 변수      | 컴파일 시     |
| HEAP   | 동적 할당 영역 (`malloc()` 등) | 런타임 중 동적으로 생성된 데이터 | 실행 중      |
| STACK  | 지역 변수 저장 영역             | 함수 호출 시 생성되는 지역 변수 | 실행 중      |

### 컴파일 vs 런타임

- 컴파일이란?
    - 작성한 코드가 컴퓨터나 기계가 처리하기 위해 0/1로 바꾸는 과정
- 컴파일 오류
    - 컴파일 에러는 문제를 일으킨 소스코드라인을 지적함
- 런타임이란?
    - 컴파일 과정을 마친 컴퓨터 프로그램이 실행되고 있는 환경 또는 동작되는 동안의 시간
    - 런타임오류
        - 소스코드가 문법의 오류가 없어도 실행 중에서 버그가 발생할 수 있음.
- 클래스 생성 시 변수(아래 코드에서의 h1)를 작성 이유 : 함수를 메모리 주소대신 쉽게 접근하기 위해서

```java
Hero h1 = new Hero("백수의 왕 사자", 100);
```

### 참조

```java
Hero h1 = new Hero("집가고 싶다", 100);
Hero h2 = h1;
h2.hp =200;
```

- 위 코드에서 hp1.hp의 값은?? 200!!!
    1. 처음 h1을 생성하여 메모리 공간에 할당 됨.
    2. 그 후 h2라는 변수에 h1에 대한 객체의 참조(메모리를 가르키는 주소)를 대입한다.

       → 따라서 h2를 바꿔도 h1이 수정됨.

- 즉, 참조라는 개념때문에 따라서 메모리를 가르킨다.

### 기본형(primitive) vs 참조형(reference)

- Primitive(기본) 타입 : int, char, double : null 값으로 초기화 안됨
- Reference(참조) 타입 : int[], String : null 값으로 초기화 됨

```java
h1 =null;
```

- 이렇게 하면 h2.hp는 얼마가 될까?

  → h1의 주소 연결을 끊는 것(주소를 비움) 뿐임.

- 따라서 h2는 그대로임

### 생성자

- 같은 클래스 내에서 생성자가 다른 생성자를 호출하고 싶으면 this를 사용하자.(C#도 동일)

```java
Hero() {
    this("도라에몽");
}
```

- this사용 시 생성자 제일 상단에 위치해야 함.

```java
Hero() {
    this.a = 10; // 오류!!!!
    this("도라에몽");
}
```

- C#에서의 생성자 오버로드 문법

```java
Hero() :this("도라에몽"){
        this.a =10;
        }
```

### Static(전역 변수)

- 한마디로 공유 자원
- static을 붙이면 **전혀 다른 메모리 주소**에 할당됨
- 또한, 처음 사용할 때 먼저 static이 붙은 변수가 메모리에 올라감(클래스 상관 x)
- but 모두 static으로 사용한다면 안됨
    - 실행 내내 메모리에 할당되어 있기 때문에, 불필요하게 많이 사용하면 메모리 공간을 낭비
    - 객체지향 원칙 위반!

  → final로 사용는 것처럼 특정 용도로 사용해야됨

- **static method**는 해당 클래스의 것일까 아닐까?

  → static method도 마찬가지로 해당 클래스의 것이 아님