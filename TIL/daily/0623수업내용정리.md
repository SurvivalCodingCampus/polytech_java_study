# 20250623 수업내용정리

### 상속
상속 : 이전에 만든 클래스와 닮았지만, 일부 다른 클래스를 만들 필요가 있을 경우 기능을 확장하기 위해서 사용

extends를 사용하여 기존 클래스를 기초로 새로운 클래스를 정의 할 수 있다.

부모 클래스의 멤버는 자동적으로 자식 클래스에 상속되므로, 자식 클래스에는 추가된 부분만 기술하면 된다.

final을 붙인 클래스는 상속이 되지 않는다.

복사하여 붙여넣기를 할 경우
* 추가, 수정에 시간이 걸린다.
* 소스의 파악이나 관리가 어려워진다.

이를 위한 해결책으로 "상속"을 활용한다.

public class SuperHero extends Hero{
}
에서 SuperHero가 sub class, Hero가 super class이다.

다중 상속은 불가능하며 모든 언어에서 string은 상속이 금지되어 있다.

### 올바른 상속
올바른 상속은 "is - a원칙" 이라고 하는 규칙에 따른 상속

SuperHero is a Hero SuperHero는 Hero의 한 종류이다.

서브클래스는 슈퍼클래스이다 라고 했을 때 말이 된다면 ok

is - a 관계가 되지 못함에도 상속을 사용한 경우는 "잘못 된 상속"

자식클래스 일수록 구체화 되고, 부모 클래스 일수록 추상적인 것으로 일반화

잘못된 상속을 하면 안 된는 이유
* 클래스를 확장할 때 현실세계와의 모순이 생긴다.
* 객체 지향의 3대 특징 중 1가지 "다향성"을 이용할 수 없게 된다.


### 오버라이드(override)
기존에 있던 기능을 재정의하여 사용하는 것을 말한다.

부모 클래스에 있는 메소드를, 자식 클래스에서 재작성 하는 것.

final이 붙은 메소드는 오버라이드 되지 않는다.

### 인스턴스
+ 인스턴스는 내부에 부모클래스의 인스턴스를 가지는 다중구조
+ 보다 외측의 인스턴스에 속하는 메소드가 우선적으로 동작
+ 외측의 인스턴스에 속하는 메소드는 super을 사용하여 내측 인스턴스의 멤버게 접근할 수 있다.

### 생성자 동작
+ 다중구조의 인스턴스가 생성되는데, JVM는 자동적으로 가장 외측 인스턴스이 생성자를 호출
+ 모든 생성자는 "부모 인스턴스이 생성자"를 호출 할 필요가 있다.
+ 생성자의 선두에 super()가 없으면, 암묵적인 "super();"가 추가
