# 20250707 수업내용정리

## 인스턴스 기본 조작
+ 모든 클래스는 object class의 메서드를 가지고 있다.

+ object 타입 변수에는 모든 인스턴스를 대입할 수 있다. -> 아무거나 다 들어감.

+ 모든 클래스는 object의 상속을 받는다.

### <Object 클래스이 대표 메서드>
+ toString() : 문자열 표현을 얻음, 사용시 생략이 가능
+ equals() : 비교
+ hashCode(): 해시값을 얻음

### set 과 list는 동등성 확인 하는 방법이 다르다.

List에서는 equals() 메서드를 오버라이드하여 동등성 규칙을 정의할 수 있다.
hashCode()를 재정의하면 Set, Map 내부에서의 동등성 규칙으로 사용된다.

hashCode()는 object 안에 들어있으며 int 값, 메모리주소(값)이다.

Set, Map 계열은 요소를 검색할 때 eqquals()보다 비용이 싼 hashCode() 비교를 사용하며, List는 순차 검색이라 느리다.
1. 모든 객체는 해시값을 가진다.
2. 동일한 객체는 항상 같은 해시값을 가진다.
3. 같은 해시갑이라고 항상 동일한 객체는 아니다.

### List에서 요소 정렬
Collections.sort()메서드는 컬렉션 내부를 정렬해준다.

기준이 없으면 정렬을 하지 못하므로 기준을 정해줘야 한다.

정렬 대상은 반드시 Comparable 인터페이스를 구현해야한다.

반대로 정렬해주고 싶은 경우 뒤집어주면 된다.

### 얕은 복사 (Shallow Copy)
+ 객체 자체는 새로 생성되지만, 객체 내의 참조 타입 필드(다른 객체에 대한 참조)는 원본과 동일한 객체를 참조한다.
+ 중첩된 객체는 복사되지 않고 주소만 복사된다. 하나의 지갑을 둘이서 사용하는 것과 같다.
+ 원본 객체의 참조 타입 필드를 변경하면 복사본의 해당 필드도 함께 변경된다.

### 깊은 복사(Deep Copy)
+ 객체 자체뿐만 아니라, 객체 내의 모든 참조 타입 필드(중첩된 객체들)까지도 재귀적으로 완전히 새로 생성하여 복사한다.
+ 원본 객체와 복사본 객체는 완전히 독립적이며 한쪽을 변경해도 다른 쪽에는 영향을 주지 않는다.

### 디폴트는 얕은 복사

## 결론
+ 객체의 내용을 알기 쉽게 보여주기 위해 다음 메서드를 재정의 해 준다.
    + toString()
+ 객체의 동등성 비교 규칙을 위해 다음 메서드를 재정의 해 준다.
    + equals
    + hashCode
+ 복사를 지원하기 위해 다음 메서드를 작성한다.
    + Cloneable 인터페이스를 구현하여 얕은 복사를 구현하기로 한다.



